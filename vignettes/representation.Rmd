---
title: "Running the BEACONs representation tools"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{representation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Intro
In this analysis we will use a set of reserves from BUILDER to assess land cover representation using the [2015 North American Land Cover map (NALC)](http://www.cec.org/north-american-environmental-atlas/land-cover-30m-2015-landsat-and-rapideye/). BUILDER creates reserves by aggregating watershed catchments to a user defined size and intactness threshold. The output is a table listing the catchments making up each reserve. The reserves we use here are created in the `builder` vignette in the `benchmarkbuilder` package.

Representation analyses typically include multiple layers assumed to represent a range of ecological processes. They often include climate layers, productivity, riparian zones etc. For this example we will use a single layer (NALC) to assess representation of the 13 land cover classes that fall within our study area. The study area is a Fundamental Drainage Area in Yukon, Canada (FDA 09EA).

The goal of the representation analysis is to identify reserves that adequately capture the target amounts of representation classes (in our case NALC classes) deemed to be proportionally representative of the study region. Usually the target amounts should be met in full in a reserve, rather than being split between multiple reserves. The idea being that the reserve should provide a sufficient area for the ecological processes associated with specific target classes to operate. In a network of multiple reserves, different target classes and different ecological processes may therefore be represented by different reserves.

Note that the tools can accommodate different objectives. For example, meeting a set of targets across a network rather than meeting each target in full in a reserve. We give an example of this below.

## Projections
All raster layers need to be projected to `NAD 1983 Albers` to match the catchments projection prior to analysis.

## Catchments
The BEACONs catchments dataset includes watershed catchment polygons with associated stream flow attributes as well as additional attributes describing catchment area and intactness.

**add download location**

**is stream flow coding system unique to BEACONs or is it a standard coding system that can be referenced and applied to other catchment datasets?**

The following functions in `beaconstools` rely on a catchments dataset:

- `dissolve_catchments_from_table()` and `extract_catchments_from_table()`: converts catchment lists (e.g. from `benchmarkbuilder`) to extracted catchments or dissolved polygons.
- `get_upstream_catchments()`: calculates the area upstream of a given polygon using catchments and stream flow attributes.
- `criteria_to_catchments()`: sums area of raster values in an intersecting catchments dataset. Used in one of the representation analysis workflows.
- `evaluate_targets_using_catchments()`: evaluate representation targets in reserves using catchments. Used in one of the representation analysis workflows.

All other functions operate on reserve polygons and do not require a catchments dataset.

## Workflow

There are two functions we can use to evaluate individual reserves: 

* `evaluate_targets_using_catchments()` uses pre-computed areas for each class. `criteria_to_catchments()` is used to sum raster class areas in each catchment, then `evaluate_targets_using_catchments()` uses these pre-computed areas to assess if targets are met in each reserve. This method can only be used for reserves made in BUILDER because each reserve is constructed of catchment planning units. Summing the pre-computed areas of the catchments making up a reserve therefore gives the area of each class in the reserve. This method is faster with large numbers of reserves because it minimizes geoprocessing of rasters.
* `evaluate_targets_using_clip()` clips the raster layer directly to each reserve and calculates the class areas. This is slower but can be used on any polygon such as an existing protected area or a proposed protected area that was not built in BUILDER and therefore is not constructed of catchment planning units.

To demonstrate both of these functions, we will evaluate BUILDER reserves using `evaluate_targets_using_catchments()`, then we will evaluate the existing protected area network using `evaluate_targets_using_clip()` and add it to our analysis.

## View inputs
```{r, message=FALSE}
library(beaconstools)
library(dplyr)
library(sf)
library(raster)
```

```{r, eval=FALSE}
# We use the following input datasets which are included in the package and are described in the help files.
?vignette_nalc
?vignette_catchments
?vignette_builder_tab
?vignette_reserves
```

```{r, fig.width=7, fig.height=5, fig.keep = 'last', message=FALSE}
# Plot the catchments over the NALC raster
plot(vignette_nalc, axes = FALSE)
plot(vignette_catchments$geometry, add = TRUE)
```

## Preparing catchments
In order to use `evaluate_targets_using_catchments()` we first need to pre-compute the NALC areas in the catchments using `criteria_to_catchments()`.

```{r, message = FALSE}
# Sum NALC values in each raster
catchments_nalc <- criteria_to_catchments(
  catchments_sf = vignette_catchments, 
  criteria_raster = vignette_nalc, 
  criteria_name = "nalc", 
  class_vals = unique(vignette_nalc))

print(catchments_nalc)
```

## Setting targets
We will use a target area of 500km2 for this analysis to match the approximate size of the reserves. The `gen_targets()` function calculates targets and lists them in the column `target_km2`, calculated as the proportion of each class across the raster, multiplied by the user provided `reserve_size`.


```{r}
# Make polygon of study region boundary by dissolving the catchments
fda <- vignette_catchments %>%
  summarise(geometry = st_union(geometry))

# Generate target table using study area boundary and LED map
# Use the reserve size matching the reserves (500km2)
target_table <- gen_targets(
  reference_sf = fda, 
  representation_raster = vignette_nalc, 
  reserve_size = 500)

print(as.data.frame(target_table))
```

## Evaluating individual reserves
The first step in the representation analysis is to evaluate each reserve individually to see if any meet all class targets. We do this with `evaluate_targets_using_catchments()` which sums the class areas in each reserve using the catchments and returns the class sums compared to the target values in a long table.
```{r}
reserve_results <- evaluate_targets_using_catchments(
  catchments_sf = catchments_nalc, 
  criteria_name = "nalc", 
  benchmark_table = vignette_builder_tab, 
  target_table = target_table, 
  network_list = colnames(vignette_builder_tab))

# View the first reserve
print(reserve_results)
```
For reference we will also generate polygons for all 26 reserves so we can view their locations on the NALC map.
```{r, fig.width=7, fig.height=5, fig.keep = 'last'}
# Use the reserves table to create polygons
reserve_polygons <- dissolve_catchments_from_table(catchments_sf = vignette_catchments, 
                                             input_table = vignette_builder_tab, 
                                             out_feature_id = "network")

plot(vignette_nalc, axes = FALSE)
plot(reserve_polygons$geometry, add = TRUE, border = 'cyan', lwd = 2)
```

## Evaluating existing protected areas
Some representation analyses will need to use non-builder reserves as input, either alone or in addition to reserves from BUILDER. We will evaluate representation for the existing reserves (clipped to our study region) using `evaluate_targets_using_clip()`. The output tables from `evaluate_targets_using_clip()` are the same format as from `evaluate_targets_using_catchments()`.

```{r, fig.width=7, fig.height=5, fig.keep='last'}
# Plot the 3 reserves inside study region
plot(vignette_nalc, axes = FALSE)
plot(vignette_existing_reserves$geometry, add=TRUE, lwd = 2, border = 'cyan')

# Evaluate the 3 reserves using the targets
pa_results <- evaluate_targets_using_clip(
  reserves_sf = vignette_existing_reserves, 
  reserves_id = "reserve", 
  representation_raster = vignette_nalc, 
  target_table = target_table)

print(pa_results)
```

## Summarizing individual reserves
At this point we have representation results for all individual reserves, as well as 3 existing reserves. We can use `summarize_representation_results()` to rank the reserves in terms of representation. We first append the existing reserve results to the builder reserve results to get everything in one table. We then summarize the results, requiring 100% of the targets to be met, but only considering targets that cover >=1% of the total target area (rare targets are difficult to represent and are often addressed as a separate part of a conservation analysis).
```{r, fig.width=7, fig.height=5, fig.keep = 'last'}
# Add reserve evaluation results to reserve_results
reserve_results <- rbind(reserve_results, pa_results)

# Summarize
benchmarks_summary <- summarize_representation_results(
  network_evaluation_table = benchmark_results,
  criteria_name = "nalc", 
  target_pass_proportion = 1, 
  target_inclusion_proportion = 0.01, 
  suffix = "", 
  gaps = TRUE)

print(benchmarks_summary[order(benchmarks_summary$nalc_gaps),])

# Join the summary results to the polygons
benchmark_polygons_nalc <- benchmark_polygons %>%
  left_join(benchmarks_summary, by = 'network')

# Map the benchmarks with the least representation gaps (i.e. 3 gaps)
plot(vignette_nalc, axes = FALSE)
plot(benchmark_polygons_nalc$geometry[benchmark_polygons_nalc$nalc_gaps==3], add = TRUE, border = 'cyan', lwd = 2)
```

The best benchmarks have 3 representation gaps. There are 23 of these. The existing reserves all have 6 or more gaps. Since no benchmarks pass all of our required targets we will now combine multiple benchmarks into networks to try and meet all targets.

## Networks
There are multiple ways we could build networks for our study region depending on our conservation objectives. Below we demonstrate two networking options with different conservation goals.

### Two non-overlapping benchmarks, ignoring existing PAs
The first scenario involves planning a network of new ecological benchmarks that meet our representation targets. This is a common scenario in areas where there are no existing reserves, or where existing reserves do not meet conservation goals (i.e. too small, not representative of region).

The analysis steps for this scenario involve building a list of network names to evaluate, removing any overlapping networks from the list (because our scenario requires a network of multiple distinct benchmarks), combining the benchmark representation results into network results, and finally ranking the resulting networks. Once we have some networks to choose from we can build their polygons and view them on a map.

```{r, fig.width=7, fig.height=5, fig.keep = 'last'}
# Generate all possible network names using 2 benchmarks per network
network_names <- gen_network_names(
  in_names = colnames(vignette_builder_tab), 
  k = 2)

head(network_names)
length(network_names)

# Now identify all networks where the two benchmarks are overlapping and remove these from the network list
# This requires feeding the benchmarks sf object into list_overlapping_benchmarks()
overlaps <- list_overlapping_benchmarks(
  benchmarks_sf = reserve_polygons)

head(overlaps)
length(overlaps)

# Remove names of overlapping networks from network_names list
network_names <- network_names[!network_names %in% overlaps]

length(network_names)

# Evaluate networks using evaluate_targets_using_benchmarks(). We could also use 
# evaluate_targets_using_catchments() but since we already have the individual reserve results, 
# evaluate_targets_using_benchmarks() will be faster. It simply returns the highest representation
# value across all reserves in the network.
# Note that this function is quite slow for large numbers of networks.
network_results <- evaluate_targets_using_benchmarks(
  benchmark_results = reserve_results, 
  network_list = network_names)

# Summarize using the same parameters as above
networks_summary <- summarize_representation_results(
  network_evaluation_table = network_results,
  criteria_name = "nalc", 
  target_pass_proportion = 1, 
  target_inclusion_proportion = 0.01, 
  suffix = "", 
  gaps = TRUE)

head(networks_summary[order(networks_summary$nalc_gaps),])

# We have 714 networks that meet all the targets (i.e. they have zero gaps)
print(nrow(networks_summary[networks_summary$nalc_gaps == 0,]))

# Make a plot showing the full footprint of the best 714 networks, along with an example of one 
# of the networks. Here we use benchmarks_to_networks() which uses the reserve sf object we
# already made to make the network polygons. We could technically do this using 
# dissolve_catchments_from_table() with the network names, but benchmarks_to_networks() is much faster.
network_polygons <- benchmarks_to_networks(
  benchmarks_sf = reserve_polygons, 
  network_list = networks_summary$network[networks_summary$nalc_gaps == 0])

# Alternate approach demoing network names in dissolve_catchments_from_table()
# network_polygons <- dissolve_catchments_from_table(catchments_sf = vignette_catchments, 
#                                              input_table = vignette_builder_tab, 
#                                              out_feature_id = "network",
#                                              dissolve_list = networks_summary$network[networks_summary$nalc_gaps == 0])

plot(vignette_nalc, axes = FALSE)
plot(network_polygons$geometry, add = TRUE, col = "darkgrey", border = "darkgrey")
plot(network_polygons$geometry[1], add = TRUE, border = 'cyan', lwd = 2)
```

### Adding a non-overlapping reserve to compliment existing PAs
In this scenario we will assume that the existing reserve ‘Tombstone_1’ is our starting point for a conservation network. We will add a reserve from builder to create a network, and we will require that the builder reserve should not overlap ‘Tombstone_1’. The process will be similar to our previous scenario, except this time we only want the network names that include ‘Tombstone_1’. We can use the `force_in` argument in `gen_network_names()` for this. We will then remove the names of any networks where the builder reserve and ‘Tombstone_1’ intersect. The resulting list of network names will be fed into the evaluation functions.

```{r, fig.width=7, fig.height=5, fig.keep = 'last'}
# Generate all network names containing 'Tombstone_1' using force_in
network_names <- gen_network_names(
  in_names = reserves_summary$network[!reserves_summary$network %in% c("Tombstone_2", "Tombstone_3")], # Drop the other 2 reserves for this example 
  k = 2,
  force_in = "Tombstone_1")

head(network_names)

# Append the 'Tombstone_1' polygon to the reserve_polygon sf object
reserve_polygons <- append_reserve(
  benchmarks_sf = reserve_polygons, 
  add_reserve = vignette_reserves[vignette_reserves$reserve == 'Tombstone_1',],
  reserve_name = "Tombstone_1")

overlaps <- list_overlapping_benchmarks(
  benchmarks_sf = reserve_polygons)

# Remove names of overlapping networks from network_names list
network_names <- network_names[!network_names %in% overlaps]

length(network_names)

# Evaluate networks using evaluate_targets_using_benchmarks(). Note that reserve_results already 
# Contains the Tombstone_1 evaluation results that we added using rbind() earlier.
network_results <- evaluate_targets_using_benchmarks(
  benchmark_results = reserve_results, 
  network_list = network_names)

# Summarize
networks_summary <- summarize_representation_results(
  network_evaluation_table = network_results,
  criteria_name = "nalc", 
  target_pass_proportion = 1, 
  target_inclusion_proportion = 0.01, 
  suffix = "", 
  gaps = TRUE)

head(networks_summary[order(networks_summary$nalc_gaps),])

# No networks meet all the targets
# We have 27 networks that meet all but 2 of the targets
print(nrow(networks_summary[networks_summary$nalc_gaps == 2,]))

# make a plot showing the full footprint of the best 27 networks, along with an example of one of 
# the networks
network_polygons <- benchmarks_to_networks(
  benchmarks_sf = reserve_polygons, 
  network_list = networks_summary$network[networks_summary$nalc_gaps == 2])

plot(vignette_nalc, axes = FALSE)
plot(network_polygons$geometry, add = TRUE, col = "darkgrey", border = "darkgrey")
plot(network_polygons$geometry[1], add = TRUE, border = "cyan", lwd = 2)
```

### Assessing targets across the full network
Sometimes we might want to assess a set of targets across a full network, instead of requiring targets to be met in full in a reserve. We can use either `evaluate_targets_using_catchments()` or `evaluate_targets_using_clip()` for this. Instead of providing a list of reserve names, we can provide network names and the functions will sum target areas across the full extent of the network, and evaluate if targets are met.
```{r}
# Make polygons for 5 randomly selected networks as an example
network_polygons <- benchmarks_to_networks(
  benchmarks_sf = reserve_polygons, 
  network_list = sample(network_names, 5))

# Evaluate
network_results <- evaluate_targets_using_clip(
  reserves_sf = network_polygons, 
  reserves_id = "network", 
  representation_raster = vignette_nalc, 
  target_table = target_table)

# Summarize
summarize_representation_results(
  network_evaluation_table = network_results,
  criteria_name = "nalc", 
  target_pass_proportion = 1, 
  target_inclusion_proportion = 0.01, 
  suffix = "", 
  gaps = TRUE)
```