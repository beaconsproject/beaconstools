---
title: "Using beaconstools to rank reserves"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Intro
Conservation planning often involves the selection of optimal reserve scenarios from a suite of reserve options. In the case of reserves produced by the partner package `benchmarkbuilder`, there could be 100's to 1000's of reserve options for a given study area. When combined into networks of multiple reserves, the number of options can often be in the millions.

The `beaconstools` package provides a range of functions for building polygons of reserves and reserve networks, and adding ecological attributes to those polygons to allow options to be ranked. Functions in the package perform the following tasks:

- **Create reserve/network polygons** - creates reserve polygons using output from the `benchmarkbuilder` package; combines `benchmarkbuilder` reserves with polygons defining other reserves such as the existing protected area network; combines reserves into networks of multiple reserves; filters reserves and networks to remove spatial overlap and redundancy.
- **Assess proportional representation** - Generates a set of targets for a raster layer; evaluates targets in reserves and networks; summarizes results.
- **Hydrology and upstream threats** - For a given reserve or polygon, identifies all watershed catchments upstream (or downstream) and calculates their area and intactness values.
- **Dendritic connectivity** - Calculates hydrological connectivity within each reserve or network.
- **Dissimilarity** - An alternate representation metric using dissimilarity statistics to compare raster distributions between a reserve and a study region.
- **Generic raster and vector summing functions** - sums the area of raster or vector layer groups in a set of reserves or networks (e.g. habitat quality, species ranges, climatic refugia etc.).
- **Generic raster averaging** - allows raster values to be averaged by reserve (e.g. climate layers, species density etc.)

## Projections
All layers need to be projected to `NAD 1983 Albers` to match the catchments projection prior to analysis.

## Network naming conventions
Individual reserves are defined as a single feature with an associated geometry, stored in a simple features object that typically contains multiple reserves and their associated geometries and attributes. Each reserve should have a unique name which is typically stored in a column named `network`. For consistency, even features representing single reserves have their names stored in the `network` column, you can think of these as networks made up of just one reserve. Simple and standardized reserve names are encouraged and must not include spaces. The `benchmarkbuilder` package for example names reserves using `PB_xxx` where `xxx` is a unique integer value for each reserve (e.g. PB_0001, PB_0002 etc.). Names for individual reserves must not contain `__` (double underscore) because that is used as the network name separator as descried below.

For networks of multiple benchmarks, the individual reserve names are combined using the separator `__`. So a network named `PB_0001__PB_0002` would be the combined geometries of the individual reserves `PB_0001` and `PB_0002`. The function `gen_network_names()` can be used for generating network names using individual reserve names. Networks generated using `gen_network_names()` are always named in alphabetical order.
```{r}
library(beaconstools)

# make a list of reserve names
reserve_names <- c("PB_0001", "PB_0002", "PA99")

# Combine into networks with 2 reserves
gen_network_names(reserve_names, 2)

# Combine into networks with 3 reserves
gen_network_names(reserve_names, 3)

# Force in PA99
gen_network_names(reserve_names, 2, "PA99")

# Randomly select 1 networks
sample(gen_network_names(reserve_names, 2), 1)
```

## Catchments - #add this to representation too
The BEACONs catchments dataset includes watershed catchment polygons with associated stream flow attributes as well as additional attributes describing catchment area and intactness.

**add download location**

**is stream flow coding system unique to BEACONs or is it a standard coding system that can be referenced and applied to other catchment datasets?**

The following functions in `beaconstools` rely on a catchments dataset:

- `dissolve_catchments_from_table()` and `extract_catchments_from_table()`: converts catchment lists (e.g. from `benchmarkbuilder`) to extracted catchments or dissolved polygons.
- `get_upstream_catchments()`: calculates the area upstream of a given polygon using catchments and stream flow attributes.
- `criteria_to_catchments()`: sums area of raster values in an intersecting catchments dataset. Used in one of the representation analysis workflows.
- `evaluate_targets_using_catchments()`: evaluate representation targets in reserves using catchments. Used in one of the representation analysis workflows.

All other functions operate on reserve polygons and do not require a catchments dataset.

## Example workflow
The following workflow demonstrates a reserve networking analysis using reserves built by `benchmarkbuilder`. Comments in the code indicate points where users could instead use polygons of other reserves such as the existing protected areas network.

### Generate benchmarks
```{r, fig.width=7, fig.height=5, fig.keep = 'last', message=FALSE}
library(benchmarkbuilder)
library(dplyr)
library(sf)
library(raster)

# First we use the benchmarkbuilder to generate some reserves using the builder() function
# Note that this stage could be skipped and an alternate set of reserves could be loaded using sf::st_read()
# For example an analysis evaluating the existing protected areas network
# Using an alternate set of polygons would remove the requirement of the benchmarkbuilder package and the accompanying catchments dataset

# generate neighbours table for catchments
nghbrs <- neighbours(builder_catchments_sample)

# Get seed list for all catchments with 100% intactness. Set benchmarks area target to 500km2.
seed <- seeds(catchments_sf = builder_catchments_sample,
             filter_intactness_col = "intact", filter_intactness_threshold = 1,
             areatarget_value = 500000000)

# Run builder() using the catchments, the seeds table defining the 500km2 area target for the 2527 seeds, and the neighbours table
# Only build benchmarks with catchments that are 80% intact, and only return benchmarks with an area-weighted intactness of at least 95%
benchmarks_tab <- builder(catchments_sf = builder_catchments_sample, seeds = seed, neighbours = nghbrs,
                          catchment_level_intactness = 0.8, benchmark_level_intactness = 0.95)

# Convert the 166 reserves to polygons
reserves_poly <- dissolve_catchments_from_table(catchments_sf = builder_catchments_sample, 
                                             input_table = benchmarks_tab, 
                                             out_feature_id = "network")

nrow(reserves_poly)

# Make map of the catchments, coloured green if intactness > 80%
# Add the outlines of all 166 benchmarks
# Highlight one benchmark in yellow as an example
plot(builder_catchments_sample$geometry[builder_catchments_sample$intact>=0.8], lty = 0, col = 'seagreen3')
plot(builder_catchments_sample$geometry[builder_catchments_sample$intact<0.8], lty = 0, col = 'grey', add = T)
plot(reserves_poly$geometry, add = T, border = 'darkgreen')
plot(reserves_poly$geometry[75], add = T, border = "gold", lwd = 2)
```


### Filter
```{r, fig.width=7, fig.height=5, fig.keep = 'last', message=FALSE}
# We have 166 reserves which when combined into networks will create a large number options, slowing down our analysis
# We can filter out redundant reserves by combining them into spatially similar groups, and selecting the best
# reserve from each group.

# group_benchmarks_using_grid() returns a vector of group values
# Here we use a 10km2 grid to group reserves
# We can add this as a new column to reserves_poly
reserves_poly$group_id <- group_benchmarks_using_grid(reserves_poly, 10000)

# We could now select one random reserve from each group to carry forward
# Or we could calculate one or more attributes for the reserves and select
# the best reserve from each group based on the attributes

# get the study are boundary by dissolving the catchments
fda <- vignette_catchments %>%
  summarise(geometry = st_union(geometry)) 

# Calculate dissimilarity values for NALC land cover map
# Lower values indicate a better between the NALC class proportions
# in the reserve and the study region
# Add the values to the polygons as a new column
reserves_poly$nalc_dissimilarity <- calc_dissimilarity(reserves_poly, fda, vignette_nalc, 'categorical')

# We can now use dplyr to select the top reserve from each group, i.e. the one with
# the lowest dissimilarity value
reserves_filtered <- reserves_poly %>%
  group_by(group_id) %>%
  slice_min(order_by = nalc_dissimilarity, n = 1) %>%
  ungroup()

nrow(reserves_filtered)

# Plot the outline of all 28 filtered reserves, highlight one
plot(builder_catchments_sample$geometry[builder_catchments_sample$intact>=0.8], lty = 0, col = 'seagreen3')
plot(builder_catchments_sample$geometry[builder_catchments_sample$intact<0.8], lty = 0, col = 'grey', add = T)
plot(reserves_filtered$geometry, add = T, border = 'darkgreen')
plot(reserves_filtered$geometry[4], add = T, border = "gold", lwd = 2)

# We can could carry out the above workflow in a single dplyr call as shown below
# reserves_filtered <- reserves_poly %>%
#   mutate(group_id = group_benchmarks_using_grid(., 10000),
#          nalc_dissimilarity = calc_dissimilarity(., fda, vignette_nalc, 'categorical')) %>%
#   group_by(group_id) %>%
#   slice_min(order_by = nalc_dissimilarity, n = 1) %>%
#   ungroup()
```

### Rank benchmarks
```{r, fig.width=7, fig.height=5, message=FALSE, fig.keep='last'}
# We can now add some ecological metrics to the benchmarks that will allow us to rank them
# We already have dissimilarity values calculated using NALC. This gives a measure of how well each reserve represents the study region distribution of land cover classes
# Values of 0.2 or less are considered good representation

# Area - first we can calculate the area of each reserve
# They are all just above 500km2 because that was the area target used in benchmarkbuilder
reserves_filtered$reserve_area_km2 <- as.numeric(st_area(reserves_filtered)) / 1000000


# Intactness - calculate the intanct area in each reserve
# sum_polygon_values() creates a table listing areas for each reserve
intact_table <- sum_polygon_values(reserves_sf = reserves_filtered,
                   reserves_id = 'network', 
                   sum_polygon = vignette_intact)

# We can then join the intact areas back to the reserves
# Note we also rename the intact area column to something more meaningful
reserves_filtered <- reserves_filtered %>%
  left_join(intact_table[c("network", "area_km2")], by = 'network') %>%
  rename(intact_km2 = area_km2)

# We might want the intactness expressed as a proportion, in which case we can calculate it as a new column
reserves_filtered$intact_proportion <- round(reserves_filtered$intact_km2 / reserves_filtered$reserve_area_km2, 2)

# Dendritic Connectivity Index - a measure of hydrological connectivity within each reserve with values ranging from 0 (low connectivity) to 1 (completely connected)

reserves_filtered$dci <- calc_dci(reserve_sf = reserves_filtered, 
                                  stream_sf = vignette_streams)

# Plot the reserve with the lowest DCI. Note how the streams are split into many different non-connected segments
plot(reserves_filtered$geometry[reserves_filtered$network == "PB_359630"])
plot(vignette_streams, add=T, col = 'orange')
```

```{r, fig.width=7, fig.height=5, message=FALSE, fig.keep='last'}
# Upstream area and area-weighted intactness - calculated using the area and area-weighted intactness of all study region catchments upstream of each reserve

# First we use get_upstream_catchments() to identify all upstream catchments for all reserves
upstream_catchment_table <- get_upstream_catchments(pa_sf = reserves_filtered, 
                                                    pa_id = 'network', 
                                                    catchments_sf = vignette_catchments)

# We can then use the table to create upstream area polygons with area and area-weighted intactness calculated
upstream_polygons <- dissolve_catchments_from_table(catchments_sf = vignette_catchments, 
                                                    input_table = upstream_catchment_table, 
                                                    out_feature_id = "network",
                                                    calc_area = TRUE,
                                                    intactness_id = "intact")

# Now we have the upstream area and area-weighted intactness values, we can join them back to the reserves using dplyr and change the names to something more meaningful
reserves_filtered <- reserves_filtered %>%
  left_join(st_drop_geometry(upstream_polygons), by = 'network') %>%
  rename(upstream_km2 = area_km2, upstream_AWI = AWI)

# Since we have polygon objects for the reserves and the upstream areas, we can visualize them together on a map, along with the study region boundary
# Plot the reserve with the largest upstream area
plot(fda$geometry)
plot(upstream_polygons$geometry[upstream_polygons$network == 'PB_362239'], col='blue', add=T)
plot(reserves_filtered$geometry[reserves_filtered$network == 'PB_362239'], col='gold', add=T)
```

```{r, fig.width=7, fig.height=5, message=FALSE, fig.keep='last'}
# Forested area - this is an example of summing the area of a raster map in each reserve. Examples of raster maps could be layers we wish to maximise in our reserves such as high quality habitat or climatic refugia. In this case we'll use a simple example of a specific land cover type in our NALC map: 'Temperate or sub-polar needleleaf forest'

# Extract the 'Temperate or sub-polar needleleaf forest' cells from the NALC raster. These have a value of 1
forested <- vignette_nalc
forested[forested != 1] <- NA

plot(forested)
plot(fda$geometry, border = 'yellow', add=T)

# Sum the forested area using sum_raster_values. Note we could have fed in the vignette_nalc object and set class_vals=1 and fill_zeros=FALSE to get the same result.
forested_table <- sum_raster_values(reserves_sf = reserves_filtered,
                  reserves_id = 'network', 
                  sum_raster = forested)

# The output is a table which we can now join to our reserves
reserves_filtered <- reserves_filtered %>%
  left_join(forested_table[c("network", "area_km2")], by = 'network') %>%
  rename(forested_km2 = area_km2)
```

```{r, fig.width=7, fig.height=5, message=FALSE, fig.keep='last'}
# We can now select the best reserves based on our attributes of interest using dplyr

```
### Generate networks

### Rank networks

